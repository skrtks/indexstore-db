// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Symbol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Symbol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Symbol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Symbol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Symbol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Symbol_2eproto;
namespace ProtoIndexStoreDB {
class LightOccurrence;
struct LightOccurrenceDefaultTypeInternal;
extern LightOccurrenceDefaultTypeInternal _LightOccurrence_default_instance_;
class LightOccurrences;
struct LightOccurrencesDefaultTypeInternal;
extern LightOccurrencesDefaultTypeInternal _LightOccurrences_default_instance_;
class Symbol;
struct SymbolDefaultTypeInternal;
extern SymbolDefaultTypeInternal _Symbol_default_instance_;
class SymbolInfo;
struct SymbolInfoDefaultTypeInternal;
extern SymbolInfoDefaultTypeInternal _SymbolInfo_default_instance_;
class SymbolOccurrence;
struct SymbolOccurrenceDefaultTypeInternal;
extern SymbolOccurrenceDefaultTypeInternal _SymbolOccurrence_default_instance_;
class SymbolOccurrenceLocation;
struct SymbolOccurrenceLocationDefaultTypeInternal;
extern SymbolOccurrenceLocationDefaultTypeInternal _SymbolOccurrenceLocation_default_instance_;
class SymbolOccurrences;
struct SymbolOccurrencesDefaultTypeInternal;
extern SymbolOccurrencesDefaultTypeInternal _SymbolOccurrences_default_instance_;
class SymbolRelation;
struct SymbolRelationDefaultTypeInternal;
extern SymbolRelationDefaultTypeInternal _SymbolRelation_default_instance_;
class Symbols;
struct SymbolsDefaultTypeInternal;
extern SymbolsDefaultTypeInternal _Symbols_default_instance_;
}  // namespace ProtoIndexStoreDB
PROTOBUF_NAMESPACE_OPEN
template<> ::ProtoIndexStoreDB::LightOccurrence* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::LightOccurrence>(Arena*);
template<> ::ProtoIndexStoreDB::LightOccurrences* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::LightOccurrences>(Arena*);
template<> ::ProtoIndexStoreDB::Symbol* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::Symbol>(Arena*);
template<> ::ProtoIndexStoreDB::SymbolInfo* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::SymbolInfo>(Arena*);
template<> ::ProtoIndexStoreDB::SymbolOccurrence* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::SymbolOccurrence>(Arena*);
template<> ::ProtoIndexStoreDB::SymbolOccurrenceLocation* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::SymbolOccurrenceLocation>(Arena*);
template<> ::ProtoIndexStoreDB::SymbolOccurrences* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::SymbolOccurrences>(Arena*);
template<> ::ProtoIndexStoreDB::SymbolRelation* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::SymbolRelation>(Arena*);
template<> ::ProtoIndexStoreDB::Symbols* Arena::CreateMaybeMessage<::ProtoIndexStoreDB::Symbols>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ProtoIndexStoreDB {

enum SymbolInfo_Kind : int {
  SymbolInfo_Kind_UNKNOWN = 0,
  SymbolInfo_Kind_MODULE = 1,
  SymbolInfo_Kind_NAMESPACE = 2,
  SymbolInfo_Kind_NAMESPACE_ALIAS = 3,
  SymbolInfo_Kind_MACRO = 4,
  SymbolInfo_Kind_ENUM = 5,
  SymbolInfo_Kind_STRUCT = 6,
  SymbolInfo_Kind_CLASS = 7,
  SymbolInfo_Kind_PROTOCOL = 8,
  SymbolInfo_Kind_EXTENSION = 9,
  SymbolInfo_Kind_UNION = 10,
  SymbolInfo_Kind_TYPE_ALIAS = 11,
  SymbolInfo_Kind_FUNCTION = 12,
  SymbolInfo_Kind_VARIABLE = 13,
  SymbolInfo_Kind_PARAMETER = 14,
  SymbolInfo_Kind_FIELD = 15,
  SymbolInfo_Kind_ENUM_CONSTANT = 16,
  SymbolInfo_Kind_INSTANCE_METHOD = 17,
  SymbolInfo_Kind_CLASS_METHOD = 18,
  SymbolInfo_Kind_STATIC_METHOD = 19,
  SymbolInfo_Kind_INSTANCE_PROPERTY = 20,
  SymbolInfo_Kind_CLASS_PROPERTY = 21,
  SymbolInfo_Kind_STATIC_PROPERTY = 22,
  SymbolInfo_Kind_CONSTRUCTOR = 23,
  SymbolInfo_Kind_DESTRUCTOR = 24,
  SymbolInfo_Kind_CONVERSION_FUNCTION = 25,
  SymbolInfo_Kind_CONCEPT = 26,
  SymbolInfo_Kind_COMMENT_TAG = 27
};
bool SymbolInfo_Kind_IsValid(int value);
constexpr SymbolInfo_Kind SymbolInfo_Kind_Kind_MIN = SymbolInfo_Kind_UNKNOWN;
constexpr SymbolInfo_Kind SymbolInfo_Kind_Kind_MAX = SymbolInfo_Kind_COMMENT_TAG;
constexpr int SymbolInfo_Kind_Kind_ARRAYSIZE = SymbolInfo_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SymbolInfo_Kind_descriptor();
template<typename T>
inline const std::string& SymbolInfo_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SymbolInfo_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SymbolInfo_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SymbolInfo_Kind_descriptor(), enum_t_value);
}
inline bool SymbolInfo_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SymbolInfo_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SymbolInfo_Kind>(
    SymbolInfo_Kind_descriptor(), name, value);
}
enum SymbolInfo_SubKind : int {
  SymbolInfo_SubKind_NONE = 0,
  SymbolInfo_SubKind_CXX_COPY_CONSTRUCTOR = 1,
  SymbolInfo_SubKind_CXX_MOVE_CONSTRUCTOR = 2,
  SymbolInfo_SubKind_ACCESSOR_GETTER = 3,
  SymbolInfo_SubKind_ACCESSOR_SETTER = 4,
  SymbolInfo_SubKind_SWIFT_ACCESSOR_WILL_SET = 5,
  SymbolInfo_SubKind_SWIFT_ACCESSOR_DID_SET = 6,
  SymbolInfo_SubKind_SWIFT_ACCESSOR_ADDRESSOR = 7,
  SymbolInfo_SubKind_SWIFT_ACCESSOR_MUTABLE_ADDRESSOR = 8,
  SymbolInfo_SubKind_SWIFT_EXTENSION_OF_STRUCT = 9,
  SymbolInfo_SubKind_SWIFT_EXTENSION_OF_CLASS = 10,
  SymbolInfo_SubKind_SWIFT_EXTENSION_OF_ENUM = 11,
  SymbolInfo_SubKind_SWIFT_EXTENSION_OF_PROTOCOL = 12,
  SymbolInfo_SubKind_SWIFT_PREFIX_OPERATOR = 13,
  SymbolInfo_SubKind_SWIFT_POSTFIX_OPERATOR = 14,
  SymbolInfo_SubKind_SWIFT_INFIX_OPERATOR = 15,
  SymbolInfo_SubKind_SWIFT_SUBSCRIPT = 16,
  SymbolInfo_SubKind_SWIFT_ASSOCIATED_TYPE = 17,
  SymbolInfo_SubKind_SWIFT_GENERIC_TYPE_PARAM = 18
};
bool SymbolInfo_SubKind_IsValid(int value);
constexpr SymbolInfo_SubKind SymbolInfo_SubKind_SubKind_MIN = SymbolInfo_SubKind_NONE;
constexpr SymbolInfo_SubKind SymbolInfo_SubKind_SubKind_MAX = SymbolInfo_SubKind_SWIFT_GENERIC_TYPE_PARAM;
constexpr int SymbolInfo_SubKind_SubKind_ARRAYSIZE = SymbolInfo_SubKind_SubKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SymbolInfo_SubKind_descriptor();
template<typename T>
inline const std::string& SymbolInfo_SubKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SymbolInfo_SubKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SymbolInfo_SubKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SymbolInfo_SubKind_descriptor(), enum_t_value);
}
inline bool SymbolInfo_SubKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SymbolInfo_SubKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SymbolInfo_SubKind>(
    SymbolInfo_SubKind_descriptor(), name, value);
}
enum SymbolInfo_Language : int {
  SymbolInfo_Language_C = 0,
  SymbolInfo_Language_OBJC = 1,
  SymbolInfo_Language_CXX = 2,
  SymbolInfo_Language_SWIFT = 3
};
bool SymbolInfo_Language_IsValid(int value);
constexpr SymbolInfo_Language SymbolInfo_Language_Language_MIN = SymbolInfo_Language_C;
constexpr SymbolInfo_Language SymbolInfo_Language_Language_MAX = SymbolInfo_Language_SWIFT;
constexpr int SymbolInfo_Language_Language_ARRAYSIZE = SymbolInfo_Language_Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SymbolInfo_Language_descriptor();
template<typename T>
inline const std::string& SymbolInfo_Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SymbolInfo_Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SymbolInfo_Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SymbolInfo_Language_descriptor(), enum_t_value);
}
inline bool SymbolInfo_Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SymbolInfo_Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SymbolInfo_Language>(
    SymbolInfo_Language_descriptor(), name, value);
}
enum SymbolOccurrence_ProviderKind : int {
  SymbolOccurrence_ProviderKind_CLANG = 1,
  SymbolOccurrence_ProviderKind_SWIFT = 2
};
bool SymbolOccurrence_ProviderKind_IsValid(int value);
constexpr SymbolOccurrence_ProviderKind SymbolOccurrence_ProviderKind_ProviderKind_MIN = SymbolOccurrence_ProviderKind_CLANG;
constexpr SymbolOccurrence_ProviderKind SymbolOccurrence_ProviderKind_ProviderKind_MAX = SymbolOccurrence_ProviderKind_SWIFT;
constexpr int SymbolOccurrence_ProviderKind_ProviderKind_ARRAYSIZE = SymbolOccurrence_ProviderKind_ProviderKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SymbolOccurrence_ProviderKind_descriptor();
template<typename T>
inline const std::string& SymbolOccurrence_ProviderKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SymbolOccurrence_ProviderKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SymbolOccurrence_ProviderKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SymbolOccurrence_ProviderKind_descriptor(), enum_t_value);
}
inline bool SymbolOccurrence_ProviderKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SymbolOccurrence_ProviderKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SymbolOccurrence_ProviderKind>(
    SymbolOccurrence_ProviderKind_descriptor(), name, value);
}
// ===================================================================

class SymbolInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.SymbolInfo) */ {
 public:
  inline SymbolInfo() : SymbolInfo(nullptr) {}
  ~SymbolInfo() override;
  explicit PROTOBUF_CONSTEXPR SymbolInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SymbolInfo(const SymbolInfo& from);
  SymbolInfo(SymbolInfo&& from) noexcept
    : SymbolInfo() {
    *this = ::std::move(from);
  }

  inline SymbolInfo& operator=(const SymbolInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolInfo& operator=(SymbolInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolInfo* internal_default_instance() {
    return reinterpret_cast<const SymbolInfo*>(
               &_SymbolInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SymbolInfo& a, SymbolInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SymbolInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SymbolInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SymbolInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SymbolInfo& from) {
    SymbolInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.SymbolInfo";
  }
  protected:
  explicit SymbolInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SymbolInfo_Kind Kind;
  static constexpr Kind UNKNOWN =
    SymbolInfo_Kind_UNKNOWN;
  static constexpr Kind MODULE =
    SymbolInfo_Kind_MODULE;
  static constexpr Kind NAMESPACE =
    SymbolInfo_Kind_NAMESPACE;
  static constexpr Kind NAMESPACE_ALIAS =
    SymbolInfo_Kind_NAMESPACE_ALIAS;
  static constexpr Kind MACRO =
    SymbolInfo_Kind_MACRO;
  static constexpr Kind ENUM =
    SymbolInfo_Kind_ENUM;
  static constexpr Kind STRUCT =
    SymbolInfo_Kind_STRUCT;
  static constexpr Kind CLASS =
    SymbolInfo_Kind_CLASS;
  static constexpr Kind PROTOCOL =
    SymbolInfo_Kind_PROTOCOL;
  static constexpr Kind EXTENSION =
    SymbolInfo_Kind_EXTENSION;
  static constexpr Kind UNION =
    SymbolInfo_Kind_UNION;
  static constexpr Kind TYPE_ALIAS =
    SymbolInfo_Kind_TYPE_ALIAS;
  static constexpr Kind FUNCTION =
    SymbolInfo_Kind_FUNCTION;
  static constexpr Kind VARIABLE =
    SymbolInfo_Kind_VARIABLE;
  static constexpr Kind PARAMETER =
    SymbolInfo_Kind_PARAMETER;
  static constexpr Kind FIELD =
    SymbolInfo_Kind_FIELD;
  static constexpr Kind ENUM_CONSTANT =
    SymbolInfo_Kind_ENUM_CONSTANT;
  static constexpr Kind INSTANCE_METHOD =
    SymbolInfo_Kind_INSTANCE_METHOD;
  static constexpr Kind CLASS_METHOD =
    SymbolInfo_Kind_CLASS_METHOD;
  static constexpr Kind STATIC_METHOD =
    SymbolInfo_Kind_STATIC_METHOD;
  static constexpr Kind INSTANCE_PROPERTY =
    SymbolInfo_Kind_INSTANCE_PROPERTY;
  static constexpr Kind CLASS_PROPERTY =
    SymbolInfo_Kind_CLASS_PROPERTY;
  static constexpr Kind STATIC_PROPERTY =
    SymbolInfo_Kind_STATIC_PROPERTY;
  static constexpr Kind CONSTRUCTOR =
    SymbolInfo_Kind_CONSTRUCTOR;
  static constexpr Kind DESTRUCTOR =
    SymbolInfo_Kind_DESTRUCTOR;
  static constexpr Kind CONVERSION_FUNCTION =
    SymbolInfo_Kind_CONVERSION_FUNCTION;
  static constexpr Kind CONCEPT =
    SymbolInfo_Kind_CONCEPT;
  static constexpr Kind COMMENT_TAG =
    SymbolInfo_Kind_COMMENT_TAG;
  static inline bool Kind_IsValid(int value) {
    return SymbolInfo_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    SymbolInfo_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    SymbolInfo_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    SymbolInfo_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return SymbolInfo_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return SymbolInfo_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return SymbolInfo_Kind_Parse(name, value);
  }

  typedef SymbolInfo_SubKind SubKind;
  static constexpr SubKind NONE =
    SymbolInfo_SubKind_NONE;
  static constexpr SubKind CXX_COPY_CONSTRUCTOR =
    SymbolInfo_SubKind_CXX_COPY_CONSTRUCTOR;
  static constexpr SubKind CXX_MOVE_CONSTRUCTOR =
    SymbolInfo_SubKind_CXX_MOVE_CONSTRUCTOR;
  static constexpr SubKind ACCESSOR_GETTER =
    SymbolInfo_SubKind_ACCESSOR_GETTER;
  static constexpr SubKind ACCESSOR_SETTER =
    SymbolInfo_SubKind_ACCESSOR_SETTER;
  static constexpr SubKind SWIFT_ACCESSOR_WILL_SET =
    SymbolInfo_SubKind_SWIFT_ACCESSOR_WILL_SET;
  static constexpr SubKind SWIFT_ACCESSOR_DID_SET =
    SymbolInfo_SubKind_SWIFT_ACCESSOR_DID_SET;
  static constexpr SubKind SWIFT_ACCESSOR_ADDRESSOR =
    SymbolInfo_SubKind_SWIFT_ACCESSOR_ADDRESSOR;
  static constexpr SubKind SWIFT_ACCESSOR_MUTABLE_ADDRESSOR =
    SymbolInfo_SubKind_SWIFT_ACCESSOR_MUTABLE_ADDRESSOR;
  static constexpr SubKind SWIFT_EXTENSION_OF_STRUCT =
    SymbolInfo_SubKind_SWIFT_EXTENSION_OF_STRUCT;
  static constexpr SubKind SWIFT_EXTENSION_OF_CLASS =
    SymbolInfo_SubKind_SWIFT_EXTENSION_OF_CLASS;
  static constexpr SubKind SWIFT_EXTENSION_OF_ENUM =
    SymbolInfo_SubKind_SWIFT_EXTENSION_OF_ENUM;
  static constexpr SubKind SWIFT_EXTENSION_OF_PROTOCOL =
    SymbolInfo_SubKind_SWIFT_EXTENSION_OF_PROTOCOL;
  static constexpr SubKind SWIFT_PREFIX_OPERATOR =
    SymbolInfo_SubKind_SWIFT_PREFIX_OPERATOR;
  static constexpr SubKind SWIFT_POSTFIX_OPERATOR =
    SymbolInfo_SubKind_SWIFT_POSTFIX_OPERATOR;
  static constexpr SubKind SWIFT_INFIX_OPERATOR =
    SymbolInfo_SubKind_SWIFT_INFIX_OPERATOR;
  static constexpr SubKind SWIFT_SUBSCRIPT =
    SymbolInfo_SubKind_SWIFT_SUBSCRIPT;
  static constexpr SubKind SWIFT_ASSOCIATED_TYPE =
    SymbolInfo_SubKind_SWIFT_ASSOCIATED_TYPE;
  static constexpr SubKind SWIFT_GENERIC_TYPE_PARAM =
    SymbolInfo_SubKind_SWIFT_GENERIC_TYPE_PARAM;
  static inline bool SubKind_IsValid(int value) {
    return SymbolInfo_SubKind_IsValid(value);
  }
  static constexpr SubKind SubKind_MIN =
    SymbolInfo_SubKind_SubKind_MIN;
  static constexpr SubKind SubKind_MAX =
    SymbolInfo_SubKind_SubKind_MAX;
  static constexpr int SubKind_ARRAYSIZE =
    SymbolInfo_SubKind_SubKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SubKind_descriptor() {
    return SymbolInfo_SubKind_descriptor();
  }
  template<typename T>
  static inline const std::string& SubKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubKind_Name.");
    return SymbolInfo_SubKind_Name(enum_t_value);
  }
  static inline bool SubKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubKind* value) {
    return SymbolInfo_SubKind_Parse(name, value);
  }

  typedef SymbolInfo_Language Language;
  static constexpr Language C =
    SymbolInfo_Language_C;
  static constexpr Language OBJC =
    SymbolInfo_Language_OBJC;
  static constexpr Language CXX =
    SymbolInfo_Language_CXX;
  static constexpr Language SWIFT =
    SymbolInfo_Language_SWIFT;
  static inline bool Language_IsValid(int value) {
    return SymbolInfo_Language_IsValid(value);
  }
  static constexpr Language Language_MIN =
    SymbolInfo_Language_Language_MIN;
  static constexpr Language Language_MAX =
    SymbolInfo_Language_Language_MAX;
  static constexpr int Language_ARRAYSIZE =
    SymbolInfo_Language_Language_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Language_descriptor() {
    return SymbolInfo_Language_descriptor();
  }
  template<typename T>
  static inline const std::string& Language_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Language>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Language_Name.");
    return SymbolInfo_Language_Name(enum_t_value);
  }
  static inline bool Language_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Language* value) {
    return SymbolInfo_Language_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kKindFieldNumber = 1,
    kSubKindFieldNumber = 2,
    kPropertiesFieldNumber = 3,
    kLanguageFieldNumber = 4,
  };
  // optional .ProtoIndexStoreDB.SymbolInfo.Kind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::ProtoIndexStoreDB::SymbolInfo_Kind kind() const;
  void set_kind(::ProtoIndexStoreDB::SymbolInfo_Kind value);
  private:
  ::ProtoIndexStoreDB::SymbolInfo_Kind _internal_kind() const;
  void _internal_set_kind(::ProtoIndexStoreDB::SymbolInfo_Kind value);
  public:

  // optional .ProtoIndexStoreDB.SymbolInfo.SubKind sub_kind = 2;
  bool has_sub_kind() const;
  private:
  bool _internal_has_sub_kind() const;
  public:
  void clear_sub_kind();
  ::ProtoIndexStoreDB::SymbolInfo_SubKind sub_kind() const;
  void set_sub_kind(::ProtoIndexStoreDB::SymbolInfo_SubKind value);
  private:
  ::ProtoIndexStoreDB::SymbolInfo_SubKind _internal_sub_kind() const;
  void _internal_set_sub_kind(::ProtoIndexStoreDB::SymbolInfo_SubKind value);
  public:

  // optional uint32 properties = 3;
  bool has_properties() const;
  private:
  bool _internal_has_properties() const;
  public:
  void clear_properties();
  uint32_t properties() const;
  void set_properties(uint32_t value);
  private:
  uint32_t _internal_properties() const;
  void _internal_set_properties(uint32_t value);
  public:

  // optional .ProtoIndexStoreDB.SymbolInfo.Language language = 4;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  ::ProtoIndexStoreDB::SymbolInfo_Language language() const;
  void set_language(::ProtoIndexStoreDB::SymbolInfo_Language value);
  private:
  ::ProtoIndexStoreDB::SymbolInfo_Language _internal_language() const;
  void _internal_set_language(::ProtoIndexStoreDB::SymbolInfo_Language value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.SymbolInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int kind_;
    int sub_kind_;
    uint32_t properties_;
    int language_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class Symbol final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.Symbol) */ {
 public:
  inline Symbol() : Symbol(nullptr) {}
  ~Symbol() override;
  explicit PROTOBUF_CONSTEXPR Symbol(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Symbol(const Symbol& from);
  Symbol(Symbol&& from) noexcept
    : Symbol() {
    *this = ::std::move(from);
  }

  inline Symbol& operator=(const Symbol& from) {
    CopyFrom(from);
    return *this;
  }
  inline Symbol& operator=(Symbol&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Symbol& default_instance() {
    return *internal_default_instance();
  }
  static inline const Symbol* internal_default_instance() {
    return reinterpret_cast<const Symbol*>(
               &_Symbol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Symbol& a, Symbol& b) {
    a.Swap(&b);
  }
  inline void Swap(Symbol* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Symbol* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Symbol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Symbol>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Symbol& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Symbol& from) {
    Symbol::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Symbol* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.Symbol";
  }
  protected:
  explicit Symbol(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kUsrFieldNumber = 3,
    kInfoFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string usr = 3;
  bool has_usr() const;
  private:
  bool _internal_has_usr() const;
  public:
  void clear_usr();
  const std::string& usr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usr();
  PROTOBUF_NODISCARD std::string* release_usr();
  void set_allocated_usr(std::string* usr);
  private:
  const std::string& _internal_usr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usr(const std::string& value);
  std::string* _internal_mutable_usr();
  public:

  // optional .ProtoIndexStoreDB.SymbolInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::ProtoIndexStoreDB::SymbolInfo& info() const;
  PROTOBUF_NODISCARD ::ProtoIndexStoreDB::SymbolInfo* release_info();
  ::ProtoIndexStoreDB::SymbolInfo* mutable_info();
  void set_allocated_info(::ProtoIndexStoreDB::SymbolInfo* info);
  private:
  const ::ProtoIndexStoreDB::SymbolInfo& _internal_info() const;
  ::ProtoIndexStoreDB::SymbolInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::ProtoIndexStoreDB::SymbolInfo* info);
  ::ProtoIndexStoreDB::SymbolInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.Symbol)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usr_;
    ::ProtoIndexStoreDB::SymbolInfo* info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class SymbolRelation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.SymbolRelation) */ {
 public:
  inline SymbolRelation() : SymbolRelation(nullptr) {}
  ~SymbolRelation() override;
  explicit PROTOBUF_CONSTEXPR SymbolRelation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SymbolRelation(const SymbolRelation& from);
  SymbolRelation(SymbolRelation&& from) noexcept
    : SymbolRelation() {
    *this = ::std::move(from);
  }

  inline SymbolRelation& operator=(const SymbolRelation& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolRelation& operator=(SymbolRelation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolRelation& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolRelation* internal_default_instance() {
    return reinterpret_cast<const SymbolRelation*>(
               &_SymbolRelation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SymbolRelation& a, SymbolRelation& b) {
    a.Swap(&b);
  }
  inline void Swap(SymbolRelation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolRelation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolRelation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SymbolRelation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SymbolRelation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SymbolRelation& from) {
    SymbolRelation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolRelation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.SymbolRelation";
  }
  protected:
  explicit SymbolRelation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 2,
    kRolesFieldNumber = 1,
  };
  // optional .ProtoIndexStoreDB.Symbol symbol = 2;
  bool has_symbol() const;
  private:
  bool _internal_has_symbol() const;
  public:
  void clear_symbol();
  const ::ProtoIndexStoreDB::Symbol& symbol() const;
  PROTOBUF_NODISCARD ::ProtoIndexStoreDB::Symbol* release_symbol();
  ::ProtoIndexStoreDB::Symbol* mutable_symbol();
  void set_allocated_symbol(::ProtoIndexStoreDB::Symbol* symbol);
  private:
  const ::ProtoIndexStoreDB::Symbol& _internal_symbol() const;
  ::ProtoIndexStoreDB::Symbol* _internal_mutable_symbol();
  public:
  void unsafe_arena_set_allocated_symbol(
      ::ProtoIndexStoreDB::Symbol* symbol);
  ::ProtoIndexStoreDB::Symbol* unsafe_arena_release_symbol();

  // optional uint64 roles = 1;
  bool has_roles() const;
  private:
  bool _internal_has_roles() const;
  public:
  void clear_roles();
  uint64_t roles() const;
  void set_roles(uint64_t value);
  private:
  uint64_t _internal_roles() const;
  void _internal_set_roles(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.SymbolRelation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::ProtoIndexStoreDB::Symbol* symbol_;
    uint64_t roles_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class SymbolOccurrenceLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.SymbolOccurrenceLocation) */ {
 public:
  inline SymbolOccurrenceLocation() : SymbolOccurrenceLocation(nullptr) {}
  ~SymbolOccurrenceLocation() override;
  explicit PROTOBUF_CONSTEXPR SymbolOccurrenceLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SymbolOccurrenceLocation(const SymbolOccurrenceLocation& from);
  SymbolOccurrenceLocation(SymbolOccurrenceLocation&& from) noexcept
    : SymbolOccurrenceLocation() {
    *this = ::std::move(from);
  }

  inline SymbolOccurrenceLocation& operator=(const SymbolOccurrenceLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolOccurrenceLocation& operator=(SymbolOccurrenceLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolOccurrenceLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolOccurrenceLocation* internal_default_instance() {
    return reinterpret_cast<const SymbolOccurrenceLocation*>(
               &_SymbolOccurrenceLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SymbolOccurrenceLocation& a, SymbolOccurrenceLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(SymbolOccurrenceLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolOccurrenceLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolOccurrenceLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SymbolOccurrenceLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SymbolOccurrenceLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SymbolOccurrenceLocation& from) {
    SymbolOccurrenceLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolOccurrenceLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.SymbolOccurrenceLocation";
  }
  protected:
  explicit SymbolOccurrenceLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kModuleNameFieldNumber = 2,
    kLineFieldNumber = 3,
    kColumnFieldNumber = 4,
    kIsSystemFieldNumber = 5,
  };
  // optional string path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string module_name = 2;
  bool has_module_name() const;
  private:
  bool _internal_has_module_name() const;
  public:
  void clear_module_name();
  const std::string& module_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module_name();
  PROTOBUF_NODISCARD std::string* release_module_name();
  void set_allocated_module_name(std::string* module_name);
  private:
  const std::string& _internal_module_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module_name(const std::string& value);
  std::string* _internal_mutable_module_name();
  public:

  // optional uint32 line = 3;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  uint32_t line() const;
  void set_line(uint32_t value);
  private:
  uint32_t _internal_line() const;
  void _internal_set_line(uint32_t value);
  public:

  // optional uint32 column = 4;
  bool has_column() const;
  private:
  bool _internal_has_column() const;
  public:
  void clear_column();
  uint32_t column() const;
  void set_column(uint32_t value);
  private:
  uint32_t _internal_column() const;
  void _internal_set_column(uint32_t value);
  public:

  // optional bool is_system = 5;
  bool has_is_system() const;
  private:
  bool _internal_has_is_system() const;
  public:
  void clear_is_system();
  bool is_system() const;
  void set_is_system(bool value);
  private:
  bool _internal_is_system() const;
  void _internal_set_is_system(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.SymbolOccurrenceLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_name_;
    uint32_t line_;
    uint32_t column_;
    bool is_system_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class SymbolOccurrence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.SymbolOccurrence) */ {
 public:
  inline SymbolOccurrence() : SymbolOccurrence(nullptr) {}
  ~SymbolOccurrence() override;
  explicit PROTOBUF_CONSTEXPR SymbolOccurrence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SymbolOccurrence(const SymbolOccurrence& from);
  SymbolOccurrence(SymbolOccurrence&& from) noexcept
    : SymbolOccurrence() {
    *this = ::std::move(from);
  }

  inline SymbolOccurrence& operator=(const SymbolOccurrence& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolOccurrence& operator=(SymbolOccurrence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolOccurrence& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolOccurrence* internal_default_instance() {
    return reinterpret_cast<const SymbolOccurrence*>(
               &_SymbolOccurrence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SymbolOccurrence& a, SymbolOccurrence& b) {
    a.Swap(&b);
  }
  inline void Swap(SymbolOccurrence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolOccurrence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolOccurrence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SymbolOccurrence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SymbolOccurrence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SymbolOccurrence& from) {
    SymbolOccurrence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolOccurrence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.SymbolOccurrence";
  }
  protected:
  explicit SymbolOccurrence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SymbolOccurrence_ProviderKind ProviderKind;
  static constexpr ProviderKind CLANG =
    SymbolOccurrence_ProviderKind_CLANG;
  static constexpr ProviderKind SWIFT =
    SymbolOccurrence_ProviderKind_SWIFT;
  static inline bool ProviderKind_IsValid(int value) {
    return SymbolOccurrence_ProviderKind_IsValid(value);
  }
  static constexpr ProviderKind ProviderKind_MIN =
    SymbolOccurrence_ProviderKind_ProviderKind_MIN;
  static constexpr ProviderKind ProviderKind_MAX =
    SymbolOccurrence_ProviderKind_ProviderKind_MAX;
  static constexpr int ProviderKind_ARRAYSIZE =
    SymbolOccurrence_ProviderKind_ProviderKind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ProviderKind_descriptor() {
    return SymbolOccurrence_ProviderKind_descriptor();
  }
  template<typename T>
  static inline const std::string& ProviderKind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ProviderKind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ProviderKind_Name.");
    return SymbolOccurrence_ProviderKind_Name(enum_t_value);
  }
  static inline bool ProviderKind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ProviderKind* value) {
    return SymbolOccurrence_ProviderKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRelationsFieldNumber = 6,
    kTargetFieldNumber = 5,
    kSymbolFieldNumber = 1,
    kLocationFieldNumber = 3,
    kRolesFieldNumber = 2,
    kProviderKindFieldNumber = 4,
  };
  // repeated .ProtoIndexStoreDB.SymbolRelation relations = 6;
  int relations_size() const;
  private:
  int _internal_relations_size() const;
  public:
  void clear_relations();
  ::ProtoIndexStoreDB::SymbolRelation* mutable_relations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolRelation >*
      mutable_relations();
  private:
  const ::ProtoIndexStoreDB::SymbolRelation& _internal_relations(int index) const;
  ::ProtoIndexStoreDB::SymbolRelation* _internal_add_relations();
  public:
  const ::ProtoIndexStoreDB::SymbolRelation& relations(int index) const;
  ::ProtoIndexStoreDB::SymbolRelation* add_relations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolRelation >&
      relations() const;

  // optional string target = 5;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const std::string& target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target();
  PROTOBUF_NODISCARD std::string* release_target();
  void set_allocated_target(std::string* target);
  private:
  const std::string& _internal_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target(const std::string& value);
  std::string* _internal_mutable_target();
  public:

  // optional .ProtoIndexStoreDB.Symbol symbol = 1;
  bool has_symbol() const;
  private:
  bool _internal_has_symbol() const;
  public:
  void clear_symbol();
  const ::ProtoIndexStoreDB::Symbol& symbol() const;
  PROTOBUF_NODISCARD ::ProtoIndexStoreDB::Symbol* release_symbol();
  ::ProtoIndexStoreDB::Symbol* mutable_symbol();
  void set_allocated_symbol(::ProtoIndexStoreDB::Symbol* symbol);
  private:
  const ::ProtoIndexStoreDB::Symbol& _internal_symbol() const;
  ::ProtoIndexStoreDB::Symbol* _internal_mutable_symbol();
  public:
  void unsafe_arena_set_allocated_symbol(
      ::ProtoIndexStoreDB::Symbol* symbol);
  ::ProtoIndexStoreDB::Symbol* unsafe_arena_release_symbol();

  // optional .ProtoIndexStoreDB.SymbolOccurrenceLocation location = 3;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::ProtoIndexStoreDB::SymbolOccurrenceLocation& location() const;
  PROTOBUF_NODISCARD ::ProtoIndexStoreDB::SymbolOccurrenceLocation* release_location();
  ::ProtoIndexStoreDB::SymbolOccurrenceLocation* mutable_location();
  void set_allocated_location(::ProtoIndexStoreDB::SymbolOccurrenceLocation* location);
  private:
  const ::ProtoIndexStoreDB::SymbolOccurrenceLocation& _internal_location() const;
  ::ProtoIndexStoreDB::SymbolOccurrenceLocation* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::ProtoIndexStoreDB::SymbolOccurrenceLocation* location);
  ::ProtoIndexStoreDB::SymbolOccurrenceLocation* unsafe_arena_release_location();

  // optional uint64 roles = 2;
  bool has_roles() const;
  private:
  bool _internal_has_roles() const;
  public:
  void clear_roles();
  uint64_t roles() const;
  void set_roles(uint64_t value);
  private:
  uint64_t _internal_roles() const;
  void _internal_set_roles(uint64_t value);
  public:

  // optional .ProtoIndexStoreDB.SymbolOccurrence.ProviderKind provider_kind = 4;
  bool has_provider_kind() const;
  private:
  bool _internal_has_provider_kind() const;
  public:
  void clear_provider_kind();
  ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind provider_kind() const;
  void set_provider_kind(::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind value);
  private:
  ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind _internal_provider_kind() const;
  void _internal_set_provider_kind(::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.SymbolOccurrence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolRelation > relations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_;
    ::ProtoIndexStoreDB::Symbol* symbol_;
    ::ProtoIndexStoreDB::SymbolOccurrenceLocation* location_;
    uint64_t roles_;
    int provider_kind_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class LightOccurrence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.LightOccurrence) */ {
 public:
  inline LightOccurrence() : LightOccurrence(nullptr) {}
  ~LightOccurrence() override;
  explicit PROTOBUF_CONSTEXPR LightOccurrence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightOccurrence(const LightOccurrence& from);
  LightOccurrence(LightOccurrence&& from) noexcept
    : LightOccurrence() {
    *this = ::std::move(from);
  }

  inline LightOccurrence& operator=(const LightOccurrence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightOccurrence& operator=(LightOccurrence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LightOccurrence& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightOccurrence* internal_default_instance() {
    return reinterpret_cast<const LightOccurrence*>(
               &_LightOccurrence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LightOccurrence& a, LightOccurrence& b) {
    a.Swap(&b);
  }
  inline void Swap(LightOccurrence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightOccurrence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LightOccurrence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LightOccurrence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LightOccurrence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LightOccurrence& from) {
    LightOccurrence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightOccurrence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.LightOccurrence";
  }
  protected:
  explicit LightOccurrence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsrFieldNumber = 1,
    kLineFieldNumber = 2,
    kColumnFieldNumber = 3,
  };
  // optional string usr = 1;
  bool has_usr() const;
  private:
  bool _internal_has_usr() const;
  public:
  void clear_usr();
  const std::string& usr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usr();
  PROTOBUF_NODISCARD std::string* release_usr();
  void set_allocated_usr(std::string* usr);
  private:
  const std::string& _internal_usr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usr(const std::string& value);
  std::string* _internal_mutable_usr();
  public:

  // optional uint32 line = 2;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  uint32_t line() const;
  void set_line(uint32_t value);
  private:
  uint32_t _internal_line() const;
  void _internal_set_line(uint32_t value);
  public:

  // optional uint32 column = 3;
  bool has_column() const;
  private:
  bool _internal_has_column() const;
  public:
  void clear_column();
  uint32_t column() const;
  void set_column(uint32_t value);
  private:
  uint32_t _internal_column() const;
  void _internal_set_column(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.LightOccurrence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usr_;
    uint32_t line_;
    uint32_t column_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class SymbolOccurrences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.SymbolOccurrences) */ {
 public:
  inline SymbolOccurrences() : SymbolOccurrences(nullptr) {}
  ~SymbolOccurrences() override;
  explicit PROTOBUF_CONSTEXPR SymbolOccurrences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SymbolOccurrences(const SymbolOccurrences& from);
  SymbolOccurrences(SymbolOccurrences&& from) noexcept
    : SymbolOccurrences() {
    *this = ::std::move(from);
  }

  inline SymbolOccurrences& operator=(const SymbolOccurrences& from) {
    CopyFrom(from);
    return *this;
  }
  inline SymbolOccurrences& operator=(SymbolOccurrences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SymbolOccurrences& default_instance() {
    return *internal_default_instance();
  }
  static inline const SymbolOccurrences* internal_default_instance() {
    return reinterpret_cast<const SymbolOccurrences*>(
               &_SymbolOccurrences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SymbolOccurrences& a, SymbolOccurrences& b) {
    a.Swap(&b);
  }
  inline void Swap(SymbolOccurrences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SymbolOccurrences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SymbolOccurrences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SymbolOccurrences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SymbolOccurrences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SymbolOccurrences& from) {
    SymbolOccurrences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SymbolOccurrences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.SymbolOccurrences";
  }
  protected:
  explicit SymbolOccurrences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOccurrenceFieldNumber = 1,
  };
  // repeated .ProtoIndexStoreDB.SymbolOccurrence occurrence = 1;
  int occurrence_size() const;
  private:
  int _internal_occurrence_size() const;
  public:
  void clear_occurrence();
  ::ProtoIndexStoreDB::SymbolOccurrence* mutable_occurrence(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolOccurrence >*
      mutable_occurrence();
  private:
  const ::ProtoIndexStoreDB::SymbolOccurrence& _internal_occurrence(int index) const;
  ::ProtoIndexStoreDB::SymbolOccurrence* _internal_add_occurrence();
  public:
  const ::ProtoIndexStoreDB::SymbolOccurrence& occurrence(int index) const;
  ::ProtoIndexStoreDB::SymbolOccurrence* add_occurrence();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolOccurrence >&
      occurrence() const;

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.SymbolOccurrences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolOccurrence > occurrence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class LightOccurrences final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.LightOccurrences) */ {
 public:
  inline LightOccurrences() : LightOccurrences(nullptr) {}
  ~LightOccurrences() override;
  explicit PROTOBUF_CONSTEXPR LightOccurrences(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LightOccurrences(const LightOccurrences& from);
  LightOccurrences(LightOccurrences&& from) noexcept
    : LightOccurrences() {
    *this = ::std::move(from);
  }

  inline LightOccurrences& operator=(const LightOccurrences& from) {
    CopyFrom(from);
    return *this;
  }
  inline LightOccurrences& operator=(LightOccurrences&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LightOccurrences& default_instance() {
    return *internal_default_instance();
  }
  static inline const LightOccurrences* internal_default_instance() {
    return reinterpret_cast<const LightOccurrences*>(
               &_LightOccurrences_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LightOccurrences& a, LightOccurrences& b) {
    a.Swap(&b);
  }
  inline void Swap(LightOccurrences* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LightOccurrences* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LightOccurrences* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LightOccurrences>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LightOccurrences& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LightOccurrences& from) {
    LightOccurrences::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LightOccurrences* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.LightOccurrences";
  }
  protected:
  explicit LightOccurrences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLightOccurrenceFieldNumber = 1,
  };
  // repeated .ProtoIndexStoreDB.LightOccurrence light_occurrence = 1;
  int light_occurrence_size() const;
  private:
  int _internal_light_occurrence_size() const;
  public:
  void clear_light_occurrence();
  ::ProtoIndexStoreDB::LightOccurrence* mutable_light_occurrence(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::LightOccurrence >*
      mutable_light_occurrence();
  private:
  const ::ProtoIndexStoreDB::LightOccurrence& _internal_light_occurrence(int index) const;
  ::ProtoIndexStoreDB::LightOccurrence* _internal_add_light_occurrence();
  public:
  const ::ProtoIndexStoreDB::LightOccurrence& light_occurrence(int index) const;
  ::ProtoIndexStoreDB::LightOccurrence* add_light_occurrence();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::LightOccurrence >&
      light_occurrence() const;

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.LightOccurrences)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::LightOccurrence > light_occurrence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// -------------------------------------------------------------------

class Symbols final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProtoIndexStoreDB.Symbols) */ {
 public:
  inline Symbols() : Symbols(nullptr) {}
  ~Symbols() override;
  explicit PROTOBUF_CONSTEXPR Symbols(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Symbols(const Symbols& from);
  Symbols(Symbols&& from) noexcept
    : Symbols() {
    *this = ::std::move(from);
  }

  inline Symbols& operator=(const Symbols& from) {
    CopyFrom(from);
    return *this;
  }
  inline Symbols& operator=(Symbols&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Symbols& default_instance() {
    return *internal_default_instance();
  }
  static inline const Symbols* internal_default_instance() {
    return reinterpret_cast<const Symbols*>(
               &_Symbols_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Symbols& a, Symbols& b) {
    a.Swap(&b);
  }
  inline void Swap(Symbols* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Symbols* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Symbols* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Symbols>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Symbols& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Symbols& from) {
    Symbols::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Symbols* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProtoIndexStoreDB.Symbols";
  }
  protected:
  explicit Symbols(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
  };
  // repeated .ProtoIndexStoreDB.Symbol symbol = 1;
  int symbol_size() const;
  private:
  int _internal_symbol_size() const;
  public:
  void clear_symbol();
  ::ProtoIndexStoreDB::Symbol* mutable_symbol(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::Symbol >*
      mutable_symbol();
  private:
  const ::ProtoIndexStoreDB::Symbol& _internal_symbol(int index) const;
  ::ProtoIndexStoreDB::Symbol* _internal_add_symbol();
  public:
  const ::ProtoIndexStoreDB::Symbol& symbol(int index) const;
  ::ProtoIndexStoreDB::Symbol* add_symbol();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::Symbol >&
      symbol() const;

  // @@protoc_insertion_point(class_scope:ProtoIndexStoreDB.Symbols)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::Symbol > symbol_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Symbol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SymbolInfo

// optional .ProtoIndexStoreDB.SymbolInfo.Kind kind = 1;
inline bool SymbolInfo::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SymbolInfo::has_kind() const {
  return _internal_has_kind();
}
inline void SymbolInfo::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::ProtoIndexStoreDB::SymbolInfo_Kind SymbolInfo::_internal_kind() const {
  return static_cast< ::ProtoIndexStoreDB::SymbolInfo_Kind >(_impl_.kind_);
}
inline ::ProtoIndexStoreDB::SymbolInfo_Kind SymbolInfo::kind() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolInfo.kind)
  return _internal_kind();
}
inline void SymbolInfo::_internal_set_kind(::ProtoIndexStoreDB::SymbolInfo_Kind value) {
  assert(::ProtoIndexStoreDB::SymbolInfo_Kind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kind_ = value;
}
inline void SymbolInfo::set_kind(::ProtoIndexStoreDB::SymbolInfo_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolInfo.kind)
}

// optional .ProtoIndexStoreDB.SymbolInfo.SubKind sub_kind = 2;
inline bool SymbolInfo::_internal_has_sub_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SymbolInfo::has_sub_kind() const {
  return _internal_has_sub_kind();
}
inline void SymbolInfo::clear_sub_kind() {
  _impl_.sub_kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::ProtoIndexStoreDB::SymbolInfo_SubKind SymbolInfo::_internal_sub_kind() const {
  return static_cast< ::ProtoIndexStoreDB::SymbolInfo_SubKind >(_impl_.sub_kind_);
}
inline ::ProtoIndexStoreDB::SymbolInfo_SubKind SymbolInfo::sub_kind() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolInfo.sub_kind)
  return _internal_sub_kind();
}
inline void SymbolInfo::_internal_set_sub_kind(::ProtoIndexStoreDB::SymbolInfo_SubKind value) {
  assert(::ProtoIndexStoreDB::SymbolInfo_SubKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sub_kind_ = value;
}
inline void SymbolInfo::set_sub_kind(::ProtoIndexStoreDB::SymbolInfo_SubKind value) {
  _internal_set_sub_kind(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolInfo.sub_kind)
}

// optional uint32 properties = 3;
inline bool SymbolInfo::_internal_has_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SymbolInfo::has_properties() const {
  return _internal_has_properties();
}
inline void SymbolInfo::clear_properties() {
  _impl_.properties_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SymbolInfo::_internal_properties() const {
  return _impl_.properties_;
}
inline uint32_t SymbolInfo::properties() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolInfo.properties)
  return _internal_properties();
}
inline void SymbolInfo::_internal_set_properties(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.properties_ = value;
}
inline void SymbolInfo::set_properties(uint32_t value) {
  _internal_set_properties(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolInfo.properties)
}

// optional .ProtoIndexStoreDB.SymbolInfo.Language language = 4;
inline bool SymbolInfo::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SymbolInfo::has_language() const {
  return _internal_has_language();
}
inline void SymbolInfo::clear_language() {
  _impl_.language_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::ProtoIndexStoreDB::SymbolInfo_Language SymbolInfo::_internal_language() const {
  return static_cast< ::ProtoIndexStoreDB::SymbolInfo_Language >(_impl_.language_);
}
inline ::ProtoIndexStoreDB::SymbolInfo_Language SymbolInfo::language() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolInfo.language)
  return _internal_language();
}
inline void SymbolInfo::_internal_set_language(::ProtoIndexStoreDB::SymbolInfo_Language value) {
  assert(::ProtoIndexStoreDB::SymbolInfo_Language_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.language_ = value;
}
inline void SymbolInfo::set_language(::ProtoIndexStoreDB::SymbolInfo_Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolInfo.language)
}

// -------------------------------------------------------------------

// Symbol

// optional .ProtoIndexStoreDB.SymbolInfo info = 1;
inline bool Symbol::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool Symbol::has_info() const {
  return _internal_has_info();
}
inline void Symbol::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ProtoIndexStoreDB::SymbolInfo& Symbol::_internal_info() const {
  const ::ProtoIndexStoreDB::SymbolInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoIndexStoreDB::SymbolInfo&>(
      ::ProtoIndexStoreDB::_SymbolInfo_default_instance_);
}
inline const ::ProtoIndexStoreDB::SymbolInfo& Symbol::info() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.Symbol.info)
  return _internal_info();
}
inline void Symbol::unsafe_arena_set_allocated_info(
    ::ProtoIndexStoreDB::SymbolInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoIndexStoreDB.Symbol.info)
}
inline ::ProtoIndexStoreDB::SymbolInfo* Symbol::release_info() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ProtoIndexStoreDB::SymbolInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoIndexStoreDB::SymbolInfo* Symbol::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.Symbol.info)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ProtoIndexStoreDB::SymbolInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::ProtoIndexStoreDB::SymbolInfo* Symbol::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoIndexStoreDB::SymbolInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::ProtoIndexStoreDB::SymbolInfo* Symbol::mutable_info() {
  ::ProtoIndexStoreDB::SymbolInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.Symbol.info)
  return _msg;
}
inline void Symbol::set_allocated_info(::ProtoIndexStoreDB::SymbolInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.Symbol.info)
}

// optional string name = 2;
inline bool Symbol::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Symbol::has_name() const {
  return _internal_has_name();
}
inline void Symbol::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Symbol::name() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.Symbol.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Symbol::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.Symbol.name)
}
inline std::string* Symbol::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.Symbol.name)
  return _s;
}
inline const std::string& Symbol::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Symbol::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Symbol::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Symbol::release_name() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.Symbol.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Symbol::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.Symbol.name)
}

// optional string usr = 3;
inline bool Symbol::_internal_has_usr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Symbol::has_usr() const {
  return _internal_has_usr();
}
inline void Symbol::clear_usr() {
  _impl_.usr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Symbol::usr() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.Symbol.usr)
  return _internal_usr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Symbol::set_usr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.usr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.Symbol.usr)
}
inline std::string* Symbol::mutable_usr() {
  std::string* _s = _internal_mutable_usr();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.Symbol.usr)
  return _s;
}
inline const std::string& Symbol::_internal_usr() const {
  return _impl_.usr_.Get();
}
inline void Symbol::_internal_set_usr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.usr_.Set(value, GetArenaForAllocation());
}
inline std::string* Symbol::_internal_mutable_usr() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.usr_.Mutable(GetArenaForAllocation());
}
inline std::string* Symbol::release_usr() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.Symbol.usr)
  if (!_internal_has_usr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.usr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usr_.IsDefault()) {
    _impl_.usr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Symbol::set_allocated_usr(std::string* usr) {
  if (usr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.usr_.SetAllocated(usr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usr_.IsDefault()) {
    _impl_.usr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.Symbol.usr)
}

// -------------------------------------------------------------------

// SymbolRelation

// optional uint64 roles = 1;
inline bool SymbolRelation::_internal_has_roles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SymbolRelation::has_roles() const {
  return _internal_has_roles();
}
inline void SymbolRelation::clear_roles() {
  _impl_.roles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t SymbolRelation::_internal_roles() const {
  return _impl_.roles_;
}
inline uint64_t SymbolRelation::roles() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolRelation.roles)
  return _internal_roles();
}
inline void SymbolRelation::_internal_set_roles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.roles_ = value;
}
inline void SymbolRelation::set_roles(uint64_t value) {
  _internal_set_roles(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolRelation.roles)
}

// optional .ProtoIndexStoreDB.Symbol symbol = 2;
inline bool SymbolRelation::_internal_has_symbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.symbol_ != nullptr);
  return value;
}
inline bool SymbolRelation::has_symbol() const {
  return _internal_has_symbol();
}
inline void SymbolRelation::clear_symbol() {
  if (_impl_.symbol_ != nullptr) _impl_.symbol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ProtoIndexStoreDB::Symbol& SymbolRelation::_internal_symbol() const {
  const ::ProtoIndexStoreDB::Symbol* p = _impl_.symbol_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoIndexStoreDB::Symbol&>(
      ::ProtoIndexStoreDB::_Symbol_default_instance_);
}
inline const ::ProtoIndexStoreDB::Symbol& SymbolRelation::symbol() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolRelation.symbol)
  return _internal_symbol();
}
inline void SymbolRelation::unsafe_arena_set_allocated_symbol(
    ::ProtoIndexStoreDB::Symbol* symbol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.symbol_);
  }
  _impl_.symbol_ = symbol;
  if (symbol) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoIndexStoreDB.SymbolRelation.symbol)
}
inline ::ProtoIndexStoreDB::Symbol* SymbolRelation::release_symbol() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoIndexStoreDB::Symbol* temp = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoIndexStoreDB::Symbol* SymbolRelation::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.SymbolRelation.symbol)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ProtoIndexStoreDB::Symbol* temp = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
  return temp;
}
inline ::ProtoIndexStoreDB::Symbol* SymbolRelation::_internal_mutable_symbol() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.symbol_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoIndexStoreDB::Symbol>(GetArenaForAllocation());
    _impl_.symbol_ = p;
  }
  return _impl_.symbol_;
}
inline ::ProtoIndexStoreDB::Symbol* SymbolRelation::mutable_symbol() {
  ::ProtoIndexStoreDB::Symbol* _msg = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolRelation.symbol)
  return _msg;
}
inline void SymbolRelation::set_allocated_symbol(::ProtoIndexStoreDB::Symbol* symbol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.symbol_;
  }
  if (symbol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(symbol);
    if (message_arena != submessage_arena) {
      symbol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, symbol, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.symbol_ = symbol;
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.SymbolRelation.symbol)
}

// -------------------------------------------------------------------

// SymbolOccurrenceLocation

// optional string path = 1;
inline bool SymbolOccurrenceLocation::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SymbolOccurrenceLocation::has_path() const {
  return _internal_has_path();
}
inline void SymbolOccurrenceLocation::clear_path() {
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SymbolOccurrenceLocation::path() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrenceLocation.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SymbolOccurrenceLocation::set_path(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrenceLocation.path)
}
inline std::string* SymbolOccurrenceLocation::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrenceLocation.path)
  return _s;
}
inline const std::string& SymbolOccurrenceLocation::_internal_path() const {
  return _impl_.path_.Get();
}
inline void SymbolOccurrenceLocation::_internal_set_path(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* SymbolOccurrenceLocation::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* SymbolOccurrenceLocation::release_path() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.SymbolOccurrenceLocation.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SymbolOccurrenceLocation::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.SymbolOccurrenceLocation.path)
}

// optional string module_name = 2;
inline bool SymbolOccurrenceLocation::_internal_has_module_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SymbolOccurrenceLocation::has_module_name() const {
  return _internal_has_module_name();
}
inline void SymbolOccurrenceLocation::clear_module_name() {
  _impl_.module_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SymbolOccurrenceLocation::module_name() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrenceLocation.module_name)
  return _internal_module_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SymbolOccurrenceLocation::set_module_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.module_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrenceLocation.module_name)
}
inline std::string* SymbolOccurrenceLocation::mutable_module_name() {
  std::string* _s = _internal_mutable_module_name();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrenceLocation.module_name)
  return _s;
}
inline const std::string& SymbolOccurrenceLocation::_internal_module_name() const {
  return _impl_.module_name_.Get();
}
inline void SymbolOccurrenceLocation::_internal_set_module_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.module_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SymbolOccurrenceLocation::_internal_mutable_module_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.module_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SymbolOccurrenceLocation::release_module_name() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.SymbolOccurrenceLocation.module_name)
  if (!_internal_has_module_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.module_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_name_.IsDefault()) {
    _impl_.module_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SymbolOccurrenceLocation::set_allocated_module_name(std::string* module_name) {
  if (module_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.module_name_.SetAllocated(module_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_name_.IsDefault()) {
    _impl_.module_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.SymbolOccurrenceLocation.module_name)
}

// optional uint32 line = 3;
inline bool SymbolOccurrenceLocation::_internal_has_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SymbolOccurrenceLocation::has_line() const {
  return _internal_has_line();
}
inline void SymbolOccurrenceLocation::clear_line() {
  _impl_.line_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SymbolOccurrenceLocation::_internal_line() const {
  return _impl_.line_;
}
inline uint32_t SymbolOccurrenceLocation::line() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrenceLocation.line)
  return _internal_line();
}
inline void SymbolOccurrenceLocation::_internal_set_line(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.line_ = value;
}
inline void SymbolOccurrenceLocation::set_line(uint32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrenceLocation.line)
}

// optional uint32 column = 4;
inline bool SymbolOccurrenceLocation::_internal_has_column() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SymbolOccurrenceLocation::has_column() const {
  return _internal_has_column();
}
inline void SymbolOccurrenceLocation::clear_column() {
  _impl_.column_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t SymbolOccurrenceLocation::_internal_column() const {
  return _impl_.column_;
}
inline uint32_t SymbolOccurrenceLocation::column() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrenceLocation.column)
  return _internal_column();
}
inline void SymbolOccurrenceLocation::_internal_set_column(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.column_ = value;
}
inline void SymbolOccurrenceLocation::set_column(uint32_t value) {
  _internal_set_column(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrenceLocation.column)
}

// optional bool is_system = 5;
inline bool SymbolOccurrenceLocation::_internal_has_is_system() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SymbolOccurrenceLocation::has_is_system() const {
  return _internal_has_is_system();
}
inline void SymbolOccurrenceLocation::clear_is_system() {
  _impl_.is_system_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SymbolOccurrenceLocation::_internal_is_system() const {
  return _impl_.is_system_;
}
inline bool SymbolOccurrenceLocation::is_system() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrenceLocation.is_system)
  return _internal_is_system();
}
inline void SymbolOccurrenceLocation::_internal_set_is_system(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_system_ = value;
}
inline void SymbolOccurrenceLocation::set_is_system(bool value) {
  _internal_set_is_system(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrenceLocation.is_system)
}

// -------------------------------------------------------------------

// SymbolOccurrence

// optional .ProtoIndexStoreDB.Symbol symbol = 1;
inline bool SymbolOccurrence::_internal_has_symbol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.symbol_ != nullptr);
  return value;
}
inline bool SymbolOccurrence::has_symbol() const {
  return _internal_has_symbol();
}
inline void SymbolOccurrence::clear_symbol() {
  if (_impl_.symbol_ != nullptr) _impl_.symbol_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ProtoIndexStoreDB::Symbol& SymbolOccurrence::_internal_symbol() const {
  const ::ProtoIndexStoreDB::Symbol* p = _impl_.symbol_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoIndexStoreDB::Symbol&>(
      ::ProtoIndexStoreDB::_Symbol_default_instance_);
}
inline const ::ProtoIndexStoreDB::Symbol& SymbolOccurrence::symbol() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrence.symbol)
  return _internal_symbol();
}
inline void SymbolOccurrence::unsafe_arena_set_allocated_symbol(
    ::ProtoIndexStoreDB::Symbol* symbol) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.symbol_);
  }
  _impl_.symbol_ = symbol;
  if (symbol) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoIndexStoreDB.SymbolOccurrence.symbol)
}
inline ::ProtoIndexStoreDB::Symbol* SymbolOccurrence::release_symbol() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoIndexStoreDB::Symbol* temp = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoIndexStoreDB::Symbol* SymbolOccurrence::unsafe_arena_release_symbol() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.SymbolOccurrence.symbol)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ProtoIndexStoreDB::Symbol* temp = _impl_.symbol_;
  _impl_.symbol_ = nullptr;
  return temp;
}
inline ::ProtoIndexStoreDB::Symbol* SymbolOccurrence::_internal_mutable_symbol() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.symbol_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoIndexStoreDB::Symbol>(GetArenaForAllocation());
    _impl_.symbol_ = p;
  }
  return _impl_.symbol_;
}
inline ::ProtoIndexStoreDB::Symbol* SymbolOccurrence::mutable_symbol() {
  ::ProtoIndexStoreDB::Symbol* _msg = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrence.symbol)
  return _msg;
}
inline void SymbolOccurrence::set_allocated_symbol(::ProtoIndexStoreDB::Symbol* symbol) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.symbol_;
  }
  if (symbol) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(symbol);
    if (message_arena != submessage_arena) {
      symbol = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, symbol, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.symbol_ = symbol;
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.SymbolOccurrence.symbol)
}

// optional uint64 roles = 2;
inline bool SymbolOccurrence::_internal_has_roles() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SymbolOccurrence::has_roles() const {
  return _internal_has_roles();
}
inline void SymbolOccurrence::clear_roles() {
  _impl_.roles_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t SymbolOccurrence::_internal_roles() const {
  return _impl_.roles_;
}
inline uint64_t SymbolOccurrence::roles() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrence.roles)
  return _internal_roles();
}
inline void SymbolOccurrence::_internal_set_roles(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.roles_ = value;
}
inline void SymbolOccurrence::set_roles(uint64_t value) {
  _internal_set_roles(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrence.roles)
}

// optional .ProtoIndexStoreDB.SymbolOccurrenceLocation location = 3;
inline bool SymbolOccurrence::_internal_has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline bool SymbolOccurrence::has_location() const {
  return _internal_has_location();
}
inline void SymbolOccurrence::clear_location() {
  if (_impl_.location_ != nullptr) _impl_.location_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::ProtoIndexStoreDB::SymbolOccurrenceLocation& SymbolOccurrence::_internal_location() const {
  const ::ProtoIndexStoreDB::SymbolOccurrenceLocation* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::ProtoIndexStoreDB::SymbolOccurrenceLocation&>(
      ::ProtoIndexStoreDB::_SymbolOccurrenceLocation_default_instance_);
}
inline const ::ProtoIndexStoreDB::SymbolOccurrenceLocation& SymbolOccurrence::location() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrence.location)
  return _internal_location();
}
inline void SymbolOccurrence::unsafe_arena_set_allocated_location(
    ::ProtoIndexStoreDB::SymbolOccurrenceLocation* location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = location;
  if (location) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ProtoIndexStoreDB.SymbolOccurrence.location)
}
inline ::ProtoIndexStoreDB::SymbolOccurrenceLocation* SymbolOccurrence::release_location() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ProtoIndexStoreDB::SymbolOccurrenceLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ProtoIndexStoreDB::SymbolOccurrenceLocation* SymbolOccurrence::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.SymbolOccurrence.location)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::ProtoIndexStoreDB::SymbolOccurrenceLocation* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::ProtoIndexStoreDB::SymbolOccurrenceLocation* SymbolOccurrence::_internal_mutable_location() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::ProtoIndexStoreDB::SymbolOccurrenceLocation>(GetArenaForAllocation());
    _impl_.location_ = p;
  }
  return _impl_.location_;
}
inline ::ProtoIndexStoreDB::SymbolOccurrenceLocation* SymbolOccurrence::mutable_location() {
  ::ProtoIndexStoreDB::SymbolOccurrenceLocation* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrence.location)
  return _msg;
}
inline void SymbolOccurrence::set_allocated_location(::ProtoIndexStoreDB::SymbolOccurrenceLocation* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.SymbolOccurrence.location)
}

// optional .ProtoIndexStoreDB.SymbolOccurrence.ProviderKind provider_kind = 4;
inline bool SymbolOccurrence::_internal_has_provider_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SymbolOccurrence::has_provider_kind() const {
  return _internal_has_provider_kind();
}
inline void SymbolOccurrence::clear_provider_kind() {
  _impl_.provider_kind_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind SymbolOccurrence::_internal_provider_kind() const {
  return static_cast< ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind >(_impl_.provider_kind_);
}
inline ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind SymbolOccurrence::provider_kind() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrence.provider_kind)
  return _internal_provider_kind();
}
inline void SymbolOccurrence::_internal_set_provider_kind(::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind value) {
  assert(::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.provider_kind_ = value;
}
inline void SymbolOccurrence::set_provider_kind(::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind value) {
  _internal_set_provider_kind(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrence.provider_kind)
}

// optional string target = 5;
inline bool SymbolOccurrence::_internal_has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SymbolOccurrence::has_target() const {
  return _internal_has_target();
}
inline void SymbolOccurrence::clear_target() {
  _impl_.target_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SymbolOccurrence::target() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrence.target)
  return _internal_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SymbolOccurrence::set_target(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.target_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.SymbolOccurrence.target)
}
inline std::string* SymbolOccurrence::mutable_target() {
  std::string* _s = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrence.target)
  return _s;
}
inline const std::string& SymbolOccurrence::_internal_target() const {
  return _impl_.target_.Get();
}
inline void SymbolOccurrence::_internal_set_target(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.target_.Set(value, GetArenaForAllocation());
}
inline std::string* SymbolOccurrence::_internal_mutable_target() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.target_.Mutable(GetArenaForAllocation());
}
inline std::string* SymbolOccurrence::release_target() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.SymbolOccurrence.target)
  if (!_internal_has_target()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.target_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SymbolOccurrence::set_allocated_target(std::string* target) {
  if (target != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.target_.SetAllocated(target, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_.IsDefault()) {
    _impl_.target_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.SymbolOccurrence.target)
}

// repeated .ProtoIndexStoreDB.SymbolRelation relations = 6;
inline int SymbolOccurrence::_internal_relations_size() const {
  return _impl_.relations_.size();
}
inline int SymbolOccurrence::relations_size() const {
  return _internal_relations_size();
}
inline void SymbolOccurrence::clear_relations() {
  _impl_.relations_.Clear();
}
inline ::ProtoIndexStoreDB::SymbolRelation* SymbolOccurrence::mutable_relations(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrence.relations)
  return _impl_.relations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolRelation >*
SymbolOccurrence::mutable_relations() {
  // @@protoc_insertion_point(field_mutable_list:ProtoIndexStoreDB.SymbolOccurrence.relations)
  return &_impl_.relations_;
}
inline const ::ProtoIndexStoreDB::SymbolRelation& SymbolOccurrence::_internal_relations(int index) const {
  return _impl_.relations_.Get(index);
}
inline const ::ProtoIndexStoreDB::SymbolRelation& SymbolOccurrence::relations(int index) const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrence.relations)
  return _internal_relations(index);
}
inline ::ProtoIndexStoreDB::SymbolRelation* SymbolOccurrence::_internal_add_relations() {
  return _impl_.relations_.Add();
}
inline ::ProtoIndexStoreDB::SymbolRelation* SymbolOccurrence::add_relations() {
  ::ProtoIndexStoreDB::SymbolRelation* _add = _internal_add_relations();
  // @@protoc_insertion_point(field_add:ProtoIndexStoreDB.SymbolOccurrence.relations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolRelation >&
SymbolOccurrence::relations() const {
  // @@protoc_insertion_point(field_list:ProtoIndexStoreDB.SymbolOccurrence.relations)
  return _impl_.relations_;
}

// -------------------------------------------------------------------

// LightOccurrence

// optional string usr = 1;
inline bool LightOccurrence::_internal_has_usr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LightOccurrence::has_usr() const {
  return _internal_has_usr();
}
inline void LightOccurrence::clear_usr() {
  _impl_.usr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LightOccurrence::usr() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.LightOccurrence.usr)
  return _internal_usr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LightOccurrence::set_usr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.usr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.LightOccurrence.usr)
}
inline std::string* LightOccurrence::mutable_usr() {
  std::string* _s = _internal_mutable_usr();
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.LightOccurrence.usr)
  return _s;
}
inline const std::string& LightOccurrence::_internal_usr() const {
  return _impl_.usr_.Get();
}
inline void LightOccurrence::_internal_set_usr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.usr_.Set(value, GetArenaForAllocation());
}
inline std::string* LightOccurrence::_internal_mutable_usr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.usr_.Mutable(GetArenaForAllocation());
}
inline std::string* LightOccurrence::release_usr() {
  // @@protoc_insertion_point(field_release:ProtoIndexStoreDB.LightOccurrence.usr)
  if (!_internal_has_usr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.usr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usr_.IsDefault()) {
    _impl_.usr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LightOccurrence::set_allocated_usr(std::string* usr) {
  if (usr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.usr_.SetAllocated(usr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usr_.IsDefault()) {
    _impl_.usr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProtoIndexStoreDB.LightOccurrence.usr)
}

// optional uint32 line = 2;
inline bool LightOccurrence::_internal_has_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LightOccurrence::has_line() const {
  return _internal_has_line();
}
inline void LightOccurrence::clear_line() {
  _impl_.line_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t LightOccurrence::_internal_line() const {
  return _impl_.line_;
}
inline uint32_t LightOccurrence::line() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.LightOccurrence.line)
  return _internal_line();
}
inline void LightOccurrence::_internal_set_line(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.line_ = value;
}
inline void LightOccurrence::set_line(uint32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.LightOccurrence.line)
}

// optional uint32 column = 3;
inline bool LightOccurrence::_internal_has_column() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LightOccurrence::has_column() const {
  return _internal_has_column();
}
inline void LightOccurrence::clear_column() {
  _impl_.column_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t LightOccurrence::_internal_column() const {
  return _impl_.column_;
}
inline uint32_t LightOccurrence::column() const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.LightOccurrence.column)
  return _internal_column();
}
inline void LightOccurrence::_internal_set_column(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.column_ = value;
}
inline void LightOccurrence::set_column(uint32_t value) {
  _internal_set_column(value);
  // @@protoc_insertion_point(field_set:ProtoIndexStoreDB.LightOccurrence.column)
}

// -------------------------------------------------------------------

// SymbolOccurrences

// repeated .ProtoIndexStoreDB.SymbolOccurrence occurrence = 1;
inline int SymbolOccurrences::_internal_occurrence_size() const {
  return _impl_.occurrence_.size();
}
inline int SymbolOccurrences::occurrence_size() const {
  return _internal_occurrence_size();
}
inline void SymbolOccurrences::clear_occurrence() {
  _impl_.occurrence_.Clear();
}
inline ::ProtoIndexStoreDB::SymbolOccurrence* SymbolOccurrences::mutable_occurrence(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.SymbolOccurrences.occurrence)
  return _impl_.occurrence_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolOccurrence >*
SymbolOccurrences::mutable_occurrence() {
  // @@protoc_insertion_point(field_mutable_list:ProtoIndexStoreDB.SymbolOccurrences.occurrence)
  return &_impl_.occurrence_;
}
inline const ::ProtoIndexStoreDB::SymbolOccurrence& SymbolOccurrences::_internal_occurrence(int index) const {
  return _impl_.occurrence_.Get(index);
}
inline const ::ProtoIndexStoreDB::SymbolOccurrence& SymbolOccurrences::occurrence(int index) const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.SymbolOccurrences.occurrence)
  return _internal_occurrence(index);
}
inline ::ProtoIndexStoreDB::SymbolOccurrence* SymbolOccurrences::_internal_add_occurrence() {
  return _impl_.occurrence_.Add();
}
inline ::ProtoIndexStoreDB::SymbolOccurrence* SymbolOccurrences::add_occurrence() {
  ::ProtoIndexStoreDB::SymbolOccurrence* _add = _internal_add_occurrence();
  // @@protoc_insertion_point(field_add:ProtoIndexStoreDB.SymbolOccurrences.occurrence)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::SymbolOccurrence >&
SymbolOccurrences::occurrence() const {
  // @@protoc_insertion_point(field_list:ProtoIndexStoreDB.SymbolOccurrences.occurrence)
  return _impl_.occurrence_;
}

// -------------------------------------------------------------------

// LightOccurrences

// repeated .ProtoIndexStoreDB.LightOccurrence light_occurrence = 1;
inline int LightOccurrences::_internal_light_occurrence_size() const {
  return _impl_.light_occurrence_.size();
}
inline int LightOccurrences::light_occurrence_size() const {
  return _internal_light_occurrence_size();
}
inline void LightOccurrences::clear_light_occurrence() {
  _impl_.light_occurrence_.Clear();
}
inline ::ProtoIndexStoreDB::LightOccurrence* LightOccurrences::mutable_light_occurrence(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.LightOccurrences.light_occurrence)
  return _impl_.light_occurrence_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::LightOccurrence >*
LightOccurrences::mutable_light_occurrence() {
  // @@protoc_insertion_point(field_mutable_list:ProtoIndexStoreDB.LightOccurrences.light_occurrence)
  return &_impl_.light_occurrence_;
}
inline const ::ProtoIndexStoreDB::LightOccurrence& LightOccurrences::_internal_light_occurrence(int index) const {
  return _impl_.light_occurrence_.Get(index);
}
inline const ::ProtoIndexStoreDB::LightOccurrence& LightOccurrences::light_occurrence(int index) const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.LightOccurrences.light_occurrence)
  return _internal_light_occurrence(index);
}
inline ::ProtoIndexStoreDB::LightOccurrence* LightOccurrences::_internal_add_light_occurrence() {
  return _impl_.light_occurrence_.Add();
}
inline ::ProtoIndexStoreDB::LightOccurrence* LightOccurrences::add_light_occurrence() {
  ::ProtoIndexStoreDB::LightOccurrence* _add = _internal_add_light_occurrence();
  // @@protoc_insertion_point(field_add:ProtoIndexStoreDB.LightOccurrences.light_occurrence)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::LightOccurrence >&
LightOccurrences::light_occurrence() const {
  // @@protoc_insertion_point(field_list:ProtoIndexStoreDB.LightOccurrences.light_occurrence)
  return _impl_.light_occurrence_;
}

// -------------------------------------------------------------------

// Symbols

// repeated .ProtoIndexStoreDB.Symbol symbol = 1;
inline int Symbols::_internal_symbol_size() const {
  return _impl_.symbol_.size();
}
inline int Symbols::symbol_size() const {
  return _internal_symbol_size();
}
inline void Symbols::clear_symbol() {
  _impl_.symbol_.Clear();
}
inline ::ProtoIndexStoreDB::Symbol* Symbols::mutable_symbol(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoIndexStoreDB.Symbols.symbol)
  return _impl_.symbol_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::Symbol >*
Symbols::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable_list:ProtoIndexStoreDB.Symbols.symbol)
  return &_impl_.symbol_;
}
inline const ::ProtoIndexStoreDB::Symbol& Symbols::_internal_symbol(int index) const {
  return _impl_.symbol_.Get(index);
}
inline const ::ProtoIndexStoreDB::Symbol& Symbols::symbol(int index) const {
  // @@protoc_insertion_point(field_get:ProtoIndexStoreDB.Symbols.symbol)
  return _internal_symbol(index);
}
inline ::ProtoIndexStoreDB::Symbol* Symbols::_internal_add_symbol() {
  return _impl_.symbol_.Add();
}
inline ::ProtoIndexStoreDB::Symbol* Symbols::add_symbol() {
  ::ProtoIndexStoreDB::Symbol* _add = _internal_add_symbol();
  // @@protoc_insertion_point(field_add:ProtoIndexStoreDB.Symbols.symbol)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProtoIndexStoreDB::Symbol >&
Symbols::symbol() const {
  // @@protoc_insertion_point(field_list:ProtoIndexStoreDB.Symbols.symbol)
  return _impl_.symbol_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoIndexStoreDB

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ProtoIndexStoreDB::SymbolInfo_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoIndexStoreDB::SymbolInfo_Kind>() {
  return ::ProtoIndexStoreDB::SymbolInfo_Kind_descriptor();
}
template <> struct is_proto_enum< ::ProtoIndexStoreDB::SymbolInfo_SubKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoIndexStoreDB::SymbolInfo_SubKind>() {
  return ::ProtoIndexStoreDB::SymbolInfo_SubKind_descriptor();
}
template <> struct is_proto_enum< ::ProtoIndexStoreDB::SymbolInfo_Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoIndexStoreDB::SymbolInfo_Language>() {
  return ::ProtoIndexStoreDB::SymbolInfo_Language_descriptor();
}
template <> struct is_proto_enum< ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind>() {
  return ::ProtoIndexStoreDB::SymbolOccurrence_ProviderKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Symbol_2eproto
